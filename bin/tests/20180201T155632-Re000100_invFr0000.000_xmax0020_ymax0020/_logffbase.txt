'/usr/local/ff++/openmpi-2.1/bin/mpirun' -np 1 /usr/local/ff++/openmpi-2.1/3.56/bin/FreeFem++-mpi -nw main_base.edp -glut ffglut
-- FreeFem++ v  3.560000 (date Jeu 20 jul 2017 18:40:39 CEST)
 Load: lg_fem lg_mesh lg_mesh3 eigenvalue parallelempi 
    1 : //////////////////////////////////////////////////////////////////////////////////////////////96
    2 : //// Wilfried Coenen 2018-01-31 //////////////////////////////////////////////////////////////96
    3 : //////////////////////////////////////////////////////////////////////////////////////////////96
    4 : 
    5 : 
    6 : 
    7 : // Load libraries, auxiliary functions, and colormaps.
    8 : 
    9 : load "MUMPS_FreeFem";
   10 : 
   11 : load "iovtk" load: iovtk 

   12 : 
   13 : include "global_vars_base.edp"// Parameters
    2 : 
    3 : real Re;
    4 : real invFr;
    5 : 
    6 : real xmax;
    7 : real ymax;
    8 : 
    9 : string dirsrc;
   10 : string dirdat;
   11 : string dirbase;
   12 : string dirstab;
   13 : string dirbaseeps;
   14 : string dirbasegrid;
   15 : 
   16 : 
   17 : 
   18 : // Colormaps
   19 : 
   20 : real[int] cmap(3*16);
   21 : real[int] kmap(3*2 );
   22 : 
   23 : 
   24 : 
   25 : // Mesh
   26 : 
   27 : int right  =  1;
   28 : int left   =  2;
   29 : int top    =  3;
   30 : int bottom =  4;
   31 : int aux    = 11;
   32 : 
   33 : mesh Th;
   34 : 
   35 : 
   36 : 
   37 : // Variational formulations
   38 : 
   39 : fespace Vh2(Th, P2);
   40 : fespace Vh1(Th, P1);
   41 : 
   42 : Vh2 u1, u2, u3, ro;
   43 : Vh1 p0;
   44 : 
   45 : 
   46 : // Fake base flow
   47 : 
   48 : real Uc;
   49 : real beta;
   50 : 
   51 : 
   52 : // Write solution
   53 : 
   54 : mesh Th2;
   55 : ;
   14 : 
   15 : include "misc.edp"func real Interp1(int Ninvec, real[int] xinvec, real[int] yinvec, real xin)
    2 : {
    3 :     int ii = 0;
    4 :     real yout = 0.0;
    5 : 
    6 :     if      (xinvec[0] < xinvec[Ninvec-1])                      // x is monotonically increasing
    7 :     {
    8 :         if      (xin <= xinvec[0])
    9 :         {
   10 :             yout = yinvec[0];
   11 :         }
   12 :         else if (xin >= xinvec[Ninvec-1])
   13 :         {
   14 :             yout = yinvec[Ninvec-1];
   15 :         }
   16 :         else
   17 :         {
   18 :             for (int i = 0; i <= Ninvec-2; i++)
   19 :             {
   20 :                 if ((xinvec[i] <= xin) && (xin < xinvec[i+1]))
   21 :                 {
   22 :                     ii = i;
   23 :                 }
   24 :             }
   25 :             yout = (xin-xinvec[ii])/(xinvec[ii+1]-xinvec[ii])*yinvec[ii+1]
   26 :                  + (xinvec[ii+1]-xin)/(xinvec[ii+1]-xinvec[ii])*yinvec[ii];
   27 :         }
   28 :     }
   29 :     else if (xinvec[Ninvec-1] < xinvec[0])                      // x is monotonically decreasing
   30 :     {
   31 :         if      (xin >= xinvec[0])
   32 :         {
   33 :             yout = yinvec[0];
   34 :         }
   35 :         else if (xin <= xinvec[Ninvec-1])
   36 :         {
   37 :             yout = yinvec[Ninvec-1];
   38 :         }
   39 :         else
   40 :         {
   41 :             for (int i = 0; i <= Ninvec-2; i++)
   42 :             {
   43 :                 if ((xinvec[i] >= xin) && (xin > xinvec[i+1]))
   44 :                 {
   45 :                     ii = i;
   46 :                 }
   47 :             }
   48 :             yout = (xin-xinvec[ii])/(xinvec[ii+1]-xinvec[ii])*yinvec[ii+1]
   49 :                  + (xinvec[ii+1]-xin)/(xinvec[ii+1]-xinvec[ii])*yinvec[ii];
   50 :         }
   51 :     }
   52 : 
   53 :     return yout;
   54 : }
   55 : 
   56 : 
   57 : 
   58 : func real Interp0(int Ninvec, real[int] xinvec, real[int] yinvec, real xin)
   59 : {
   60 :     int ii = 0;
   61 :     real yout = 0.0;
   62 : 
   63 :     if      (xinvec[0] < xinvec[Ninvec-1])                      // x is monotonically increasing
   64 :     {
   65 :         if      (xin <= xinvec[0])
   66 :         {
   67 :             yout = yinvec[0];
   68 :         }
   69 :         else if (xin >= xinvec[Ninvec-1])
   70 :         {
   71 :             yout = yinvec[Ninvec-1];
   72 :         }
   73 :         else
   74 :         {
   75 :             for (int i = 0; i <= Ninvec-2; i++)
   76 :             {
   77 :                 if ((xinvec[i] <= xin) && (xin < xinvec[i+1]))
   78 :                 {
   79 :                     if (abs(xin - xinvec[i]) < abs(xin - xinvec[i+1]))
   80 :                     {
   81 :                         ii = i;
   82 :                     }
   83 :                     else
   84 :                     {
   85 :                         ii = i+1;
   86 :                     }
   87 :                 }
   88 :             }
   89 :             yout = yinvec[ii];
   90 :         }
   91 :     }
   92 :     else if (xinvec[Ninvec-1] < xinvec[0])                      // x is monotonically decreasing
   93 :     {
   94 :         if      (xin >= xinvec[0])
   95 :         {
   96 :             yout = yinvec[0];
   97 :         }
   98 :         else if (xin <= xinvec[Ninvec-1])
   99 :         {
  100 :             yout = yinvec[Ninvec-1];
  101 :         }
  102 :         else
  103 :         {
  104 :             for (int i = 0; i <= Ninvec-2; i++)
  105 :             {
  106 :                 if ((xinvec[i] >= xin) && (xin > xinvec[i+1]))
  107 :                 {
  108 :                     if (abs(xin - xinvec[i]) < abs(xin - xinvec[i+1]))
  109 :                     {
  110 :                         ii = i;
  111 :                     }
  112 :                     else
  113 :                     {
  114 :                         ii = i+1;
  115 :                     }
  116 :                 }
  117 :             }
  118 :             yout = yinvec[ii];
  119 :         }
  120 :     }
  121 : 
  122 :     return yout;
  123 : }
  124 : 
  125 : 
  126 : 
  127 : func real Interp1Fast(int Ninvec, real[int] xinvec, real[int] yinvec, real xin)
  128 : {
  129 :     int ii = 0;
  130 :     real yout = 0.0;
  131 :     int nle = 0;
  132 :     int nri = Ninvec-1;
  133 :     int nmi = floor((nle + nri)/2.0+1.0e-12);
  134 : 
  135 :     if      (xinvec[nle] < xinvec[nri])                         // x is increasing
  136 :     {
  137 :         if      (xin <= xinvec[nle])                            // smaller than smallest x
  138 :         {
  139 :             yout = yinvec[nle];
  140 :         }
  141 :         else if (xinvec[nri] <= xin)                            // larger than largest x
  142 :         {
  143 :             yout = yinvec[nri];
  144 :         }
  145 :         else
  146 :         {
  147 :             while ((nri - nle) > 1)
  148 :             {
  149 :                 if   (xin < xinvec[nmi])
  150 :                 {
  151 :                     nri = nmi;
  152 :                 }
  153 :                 else
  154 :                 {
  155 :                     nle = nmi;
  156 :                 }
  157 :                 nmi = floor((nle + nri)/2.0+1.0e-12);
  158 :             }
  159 :             yout = (xin-xinvec[nle])/(xinvec[nri]-xinvec[nle])*yinvec[nri]
  160 :                  + (xinvec[nri]-xin)/(xinvec[nri]-xinvec[nle])*yinvec[nle];
  161 :         }
  162 :     }
  163 :     else if (xinvec[nle] > xinvec[nri])                         // x is decreasing
  164 :     {
  165 :         if      (xin >= xinvec[nle])                            // larger than largest x
  166 :         {
  167 :             yout = yinvec[nle];
  168 :         }
  169 :         else if (xinvec[nri] >= xin)                            // smaller than smallest x
  170 :         {
  171 :             yout = yinvec[nri];
  172 :         }
  173 :         else
  174 :         {
  175 :             while ((nri - nle) > 1)
  176 :             {
  177 :                 if   (xin > xinvec[nmi])
  178 :                 {
  179 :                     nri = nmi;
  180 :                 }
  181 :                 else
  182 :                 {
  183 :                     nle = nmi;
  184 :                 }
  185 :                 nmi = floor((nle + nri)/2.0+1.0e-12);
  186 :             }
  187 :             yout = (xin-xinvec[nle])/(xinvec[nri]-xinvec[nle])*yinvec[nri]
  188 :                  + (xinvec[nri]-xin)/(xinvec[nri]-xinvec[nle])*yinvec[nle];
  189 :         }
  190 :     }
  191 : 
  192 :     return yout;
  193 : }
  194 : 
  195 : 
  196 : 
  197 : func string Int2Str(int intnum, int strlength)
  198 : {
  199 :     string leadingzeros = "";
  200 : 
  201 :     for (int skk = strlength-1; skk > 0; skk--)
  202 :     {
  203 :         if (intnum > 10^skk-1) { break;                           }
  204 :         else                   { leadingzeros = "0"+leadingzeros; }
  205 :     }
  206 : 
  207 :     return leadingzeros+intnum;
  208 : }
  209 : 
  210 : 
  211 : 
  212 : func int GetNumElemsFromFile(string filenamestr)
  213 : {
  214 :     int  jj    = 0;
  215 :     int  flag  = 0;
  216 :     real dummyvar ;
  217 :     {
  218 :         ifstream file(filenamestr);
  219 :         while(flag == 0)
  220 :         {
  221 :             if(file.eof == 0)
  222 :             {
  223 :                 file >> dummyvar;
  224 :                 jj += 1;
  225 :             }
  226 :             else
  227 :             {
  228 :                 flag = 1;
  229 :             }
  230 :         }
  231 :     }
  232 :     return jj - 1;
  233 : }
  234 : 
  235 : 
  236 : 
  237 : func real[int] ReadVectorFromFile(int numlinesinfile, string filename)
  238 : {
  239 :     int Nin = numlinesinfile;
  240 :     real[int] vectorin(Nin);
  241 :     {
  242 :         ifstream file(filename);
  243 :         for (int ii = 0; ii < Nin; ii++)
  244 :         {
  245 :             file >> vectorin[ii];
  246 :         }
  247 :     }
  248 :     return vectorin;
  249 : }
  250 : 
  251 : 
  252 : 
  253 : func real ReadScalarFromFile(string filename)
  254 : {
  255 :     real scalarin;
  256 :     {
  257 :         ifstream file(filename);
  258 :         file >> scalarin;
  259 :     }
  260 :     return scalarin;
  261 : }
  262 : 
  263 : ;
   16 : 
   17 : include "colors.edp"func real[int,int] Rgb2Hsv(real[int,int] & rgbmap)
    2 : {
    3 :     int rgbmapN = rgbmap.n;
    4 : 
    5 :     real[int] rgbR(rgbmapN);
    6 :     real[int] rgbG(rgbmapN);
    7 :     real[int] rgbB(rgbmapN);
    8 :     real[int] hsvH(rgbmapN);
    9 :     real[int] hsvS(rgbmapN);
   10 :     real[int] hsvV(rgbmapN);
   11 : 
   12 :     real[int,int] hsvmap(rgbmapN,3);
   13 : 
   14 :     real rgbCmax;
   15 :     real rgbCmin;
   16 :     real rgbdelta;
   17 : 
   18 :     for(int iii = 0; iii < rgbmapN; iii++)
   19 :     {
   20 :         rgbR(iii) = rgbmap(iii,0);
   21 :         rgbG(iii) = rgbmap(iii,1);
   22 :         rgbB(iii) = rgbmap(iii,2);
   23 : 
   24 :         rgbCmax  = max(max(rgbR(iii),rgbG(iii)),rgbB(iii));
   25 :         rgbCmin  = min(min(rgbR(iii),rgbG(iii)),rgbB(iii));
   26 :         rgbdelta = rgbCmax - rgbCmin;
   27 : 
   28 :         hsvV(iii) = rgbCmax;
   29 : 
   30 :         if (rgbCmax > 0.0)
   31 :         {
   32 :             hsvS(iii) = rgbdelta/rgbCmax;
   33 :         }
   34 :         else
   35 :         {
   36 :             hsvS(iii) = 0.0;
   37 :             hsvH(iii) = 0.0;
   38 :         }
   39 : 
   40 :         if (rgbdelta > 0.0)
   41 :         {
   42 :             if        (rgbCmax == rgbR(iii))
   43 :             {
   44 :                 hsvH(iii) = 60.0/360.0 * (rgbG(iii)-rgbB(iii))/rgbdelta;
   45 :             }
   46 :             else if   (rgbCmax == rgbG(iii))
   47 :             {
   48 :                 hsvH(iii) = 60.0/360.0 * ((rgbB(iii)-rgbR(iii))/rgbdelta+2.0);
   49 :             }
   50 :             else if   (rgbCmax == rgbB(iii))
   51 :             {
   52 :                 hsvH(iii) = 60.0/360.0 * ((rgbR(iii)-rgbG(iii))/rgbdelta+4.0);
   53 :             }
   54 :         }
   55 :         else
   56 :         {
   57 :             hsvH(iii) = 0.0;
   58 :         }
   59 : 
   60 :         if (hsvH(iii) < 0.0)
   61 :         {
   62 :             hsvH(iii) = hsvH(iii) + 1.0;
   63 :         }
   64 : 
   65 :         hsvmap(iii,0) = hsvH(iii);
   66 :         hsvmap(iii,1) = hsvS(iii);
   67 :         hsvmap(iii,2) = hsvV(iii);
   68 :     }
   69 : 
   70 :     return hsvmap;
   71 : }
   72 : 
   73 : 
   74 : 
   75 : func real[int] CubeHelixFF(int  cbhlxN,
   76 :                            real cbhlxstart,
   77 :                            real cbhlxrots,
   78 :                            real cbhlxsat,
   79 :                            real cbhlxgam)
   80 : {
   81 : // To use, for example:
   82 : // real[int] cmapCubeHelix = CubeHelixFF(32, 0.50, -1.50, 1.0, 1.0);
   83 : 
   84 :     real[int,int] cbhlxmap(cbhlxN,3);
   85 :     real[int,int] cbhlxhsv(cbhlxN,3);
   86 :     real[int]     cbhlxhsvvec(3*cbhlxN);
   87 :     real[int]     cbhlxvec(cbhlxN);
   88 :     real[int]     cbhlxang(cbhlxN);
   89 :     real[int,int] cbhlxcof(3,2);
   90 :     int ccc;
   91 : 
   92 :     cbhlxcof = [ [-0.14861,  1.78277],
   93 :                  [-0.29227, -0.90649],
   94 :                  [ 1.97294,  0.00000] ];
   95 : 
   96 :     cbhlxvec = 0.0 : 1.0/(cbhlxN-1) : 1.0;
   97 : 
   98 :     for(int iii = cbhlxN-1; iii >= 0; iii--)
   99 :     {
  100 :         cbhlxang(iii) = 2.0*pi*(cbhlxstart/3.0+1.0+cbhlxrots*cbhlxvec(iii));
  101 : 
  102 :         for(int jjj = 0; jjj < 3; jjj++)
  103 :         {
  104 :             cbhlxmap(iii,jjj) = cbhlxvec(iii)^cbhlxgam + cbhlxsat*cbhlxvec(iii)^cbhlxgam
  105 :                                 *0.5*(1.0-cbhlxvec(iii)^cbhlxgam)
  106 :                                 *(cbhlxcof(jjj,0)*cos(cbhlxang(iii))
  107 :                                 + cbhlxcof(jjj,1)*sin(cbhlxang(iii)));
  108 :         }
  109 :     }
  110 : 
  111 :     cbhlxhsv = Rgb2Hsv(cbhlxmap);
  112 : 
  113 :     ccc = 0;
  114 : 
  115 :     for(int iii = 0; iii < cbhlxN; iii++)
  116 :     {
  117 :         for(int jjj = 0; jjj < 3; jjj++)
  118 :         {
  119 :             cbhlxhsvvec(ccc) = cbhlxhsv(iii,jjj);
  120 :             ccc = ccc+1;
  121 :         }
  122 :     }
  123 : 
  124 :     return cbhlxhsvvec;
  125 : }
  126 : 
  127 : 
  128 : 
  129 : func real[int] BrewerFF(string mapname)
  130 : {
  131 :     int N = 3*16;
 *** Warning  The identifier N hide a Global identifier  

  132 :     real[int] cmaphsv(N);
  133 : 
  134 :     include "colors_brewer_16.edp"real[int] cmaphsvBlues = [
    2 : 0.599, 0.925, 0.420,
    3 : 0.593, 0.940, 0.524,
    4 : 0.586, 0.948, 0.604,
    5 : 0.580, 0.914, 0.659,
    6 : 0.578, 0.835, 0.700,
    7 : 0.573, 0.767, 0.735,
    8 : 0.567, 0.694, 0.765,
    9 : 0.564, 0.620, 0.796,
   10 : 0.563, 0.542, 0.826,
   11 : 0.561, 0.453, 0.850,
   12 : 0.557, 0.352, 0.869,
   13 : 0.559, 0.270, 0.892,
   14 : 0.572, 0.208, 0.920,
   15 : 0.583, 0.161, 0.942,
   16 : 0.582, 0.128, 0.957,
   17 : 0.580, 0.097, 0.970
   18 : ];
   19 : 
   20 : real[int] cmaphsvBuGn = [
   21 : 0.400, 1.000, 0.267,
   22 : 0.397, 1.000, 0.348,
   23 : 0.400, 1.000, 0.419,
   24 : 0.397, 0.920, 0.478,
   25 : 0.388, 0.773, 0.531,
   26 : 0.394, 0.699, 0.595,
   27 : 0.409, 0.648, 0.662,
   28 : 0.423, 0.585, 0.708,
   29 : 0.439, 0.513, 0.743,
   30 : 0.450, 0.433, 0.781,
   31 : 0.457, 0.344, 0.822,
   32 : 0.462, 0.261, 0.862,
   33 : 0.463, 0.181, 0.903,
   34 : 0.474, 0.125, 0.931,
   35 : 0.511, 0.095, 0.954,
   36 : 0.534, 0.077, 0.978
   37 : ];
   38 : 
   39 : real[int] cmaphsvBuPu = [
   40 : 0.838, 1.000, 0.302,
   41 : 0.847, 0.962, 0.428,
   42 : 0.843, 0.893, 0.502,
   43 : 0.823, 0.769, 0.546,
   44 : 0.801, 0.616, 0.604,
   45 : 0.780, 0.512, 0.646,
   46 : 0.757, 0.426, 0.681,
   47 : 0.720, 0.346, 0.718,
   48 : 0.666, 0.275, 0.757,
   49 : 0.618, 0.303, 0.796,
   50 : 0.593, 0.291, 0.835,
   51 : 0.580, 0.262, 0.865,
   52 : 0.580, 0.209, 0.886,
   53 : 0.580, 0.158, 0.908,
   54 : 0.574, 0.114, 0.936,
   55 : 0.566, 0.078, 0.959
   56 : ];
   57 : 
   58 : real[int] cmaphsvGnBu = [
   59 : 0.590, 0.938, 0.506,
   60 : 0.580, 0.948, 0.600,
   61 : 0.570, 0.953, 0.668,
   62 : 0.563, 0.903, 0.707,
   63 : 0.558, 0.795, 0.737,
   64 : 0.552, 0.723, 0.780,
   65 : 0.544, 0.660, 0.823,
   66 : 0.530, 0.567, 0.819,
   67 : 0.502, 0.440, 0.785,
   68 : 0.463, 0.358, 0.818,
   69 : 0.409, 0.282, 0.849,
   70 : 0.356, 0.217, 0.877,
   71 : 0.319, 0.178, 0.905,
   72 : 0.299, 0.156, 0.926,
   73 : 0.298, 0.126, 0.941,
   74 : 0.297, 0.095, 0.955
   75 : ];
   76 : 
   77 : real[int] cmaphsvGreens = [
   78 : 0.400, 1.000, 0.267,
   79 : 0.397, 1.000, 0.348,
   80 : 0.400, 1.000, 0.419,
   81 : 0.399, 0.920, 0.478,
   82 : 0.390, 0.773, 0.531,
   83 : 0.384, 0.699, 0.590,
   84 : 0.380, 0.645, 0.650,
   85 : 0.369, 0.563, 0.702,
   86 : 0.348, 0.455, 0.747,
   87 : 0.330, 0.375, 0.789,
   88 : 0.321, 0.320, 0.829,
   89 : 0.315, 0.266, 0.863,
   90 : 0.309, 0.213, 0.894,
   91 : 0.304, 0.164, 0.920,
   92 : 0.298, 0.119, 0.944,
   93 : 0.293, 0.082, 0.963
   94 : ];
   95 : 
   96 : real[int] cmaphsvGreys = [
   97 : 0.000, 0.000, 0.000,
   98 : 0.000, 0.000, 0.065,
   99 : 0.000, 0.000, 0.136,
  100 : 0.000, 0.000, 0.218,
  101 : 0.000, 0.000, 0.303,
  102 : 0.000, 0.000, 0.370,
  103 : 0.000, 0.000, 0.428,
  104 : 0.000, 0.000, 0.490,
  105 : 0.000, 0.000, 0.555,
  106 : 0.000, 0.000, 0.624,
  107 : 0.000, 0.000, 0.699,
  108 : 0.000, 0.000, 0.763,
  109 : 0.000, 0.000, 0.815,
  110 : 0.000, 0.000, 0.863,
  111 : 0.000, 0.000, 0.908,
  112 : 0.000, 0.000, 0.945
  113 : ];
  114 : 
  115 : real[int] cmaphsvOrRd = [
  116 : 0.000, 1.000, 0.498,
  117 : 0.000, 1.000, 0.602,
  118 : 0.000, 1.000, 0.692,
  119 : 0.004, 0.959, 0.767,
  120 : 0.013, 0.874, 0.829,
  121 : 0.020, 0.795, 0.881,
  122 : 0.025, 0.717, 0.924,
  123 : 0.036, 0.682, 0.957,
  124 : 0.047, 0.664, 0.983,
  125 : 0.059, 0.616, 0.990,
  126 : 0.069, 0.526, 0.992,
  127 : 0.079, 0.458, 0.992,
  128 : 0.089, 0.413, 0.992,
  129 : 0.096, 0.359, 0.992,
  130 : 0.099, 0.281, 0.994,
  131 : 0.099, 0.204, 0.996
  132 : ];
  133 : 
  134 : real[int] cmaphsvOranges = [
  135 : 0.047, 0.969, 0.498,
  136 : 0.050, 0.975, 0.565,
  137 : 0.052, 0.981, 0.641,
  138 : 0.053, 0.989, 0.737,
  139 : 0.054, 0.995, 0.834,
  140 : 0.058, 0.982, 0.892,
  141 : 0.063, 0.939, 0.933,
  142 : 0.067, 0.884, 0.964,
  143 : 0.069, 0.804, 0.988,
  144 : 0.072, 0.721, 0.992,
  145 : 0.075, 0.635, 0.992,
  146 : 0.078, 0.540, 0.992,
  147 : 0.082, 0.434, 0.992,
  148 : 0.085, 0.337, 0.992,
  149 : 0.084, 0.252, 0.994,
  150 : 0.083, 0.181, 0.996
  151 : ];
  152 : 
  153 : real[int] cmaphsvPuBu = [
  154 : 0.562, 0.977, 0.345,
  155 : 0.562, 0.973, 0.453,
  156 : 0.562, 0.972, 0.543,
  157 : 0.563, 0.972, 0.619,
  158 : 0.563, 0.972, 0.679,
  159 : 0.559, 0.918, 0.716,
  160 : 0.558, 0.771, 0.743,
  161 : 0.559, 0.636, 0.771,
  162 : 0.566, 0.499, 0.799,
  163 : 0.574, 0.387, 0.824,
  164 : 0.585, 0.294, 0.846,
  165 : 0.601, 0.212, 0.867,
  166 : 0.629, 0.139, 0.887,
  167 : 0.670, 0.086, 0.907,
  168 : 0.705, 0.063, 0.930,
  169 : 0.750, 0.043, 0.951
  170 : ];
  171 : 
  172 : real[int] cmaphsvPuBuGn = [
  173 : 0.461, 0.986, 0.275,
  174 : 0.460, 0.989, 0.354,
  175 : 0.469, 0.991, 0.417,
  176 : 0.486, 0.990, 0.462,
  177 : 0.506, 0.986, 0.517,
  178 : 0.528, 0.918, 0.624,
  179 : 0.553, 0.765, 0.730,
  180 : 0.561, 0.655, 0.776,
  181 : 0.560, 0.556, 0.800,
  182 : 0.565, 0.442, 0.824,
  183 : 0.581, 0.310, 0.846,
  184 : 0.602, 0.210, 0.867,
  185 : 0.629, 0.138, 0.887,
  186 : 0.673, 0.087, 0.907,
  187 : 0.734, 0.072, 0.925,
  188 : 0.793, 0.056, 0.944
  189 : ];
  190 : 
  191 : real[int] cmaphsvPuRd = [
  192 : 0.950, 1.000, 0.404,
  193 : 0.933, 1.000, 0.492,
  194 : 0.927, 1.000, 0.584,
  195 : 0.932, 0.974, 0.690,
  196 : 0.939, 0.923, 0.790,
  197 : 0.934, 0.886, 0.856,
  198 : 0.920, 0.845, 0.901,
  199 : 0.909, 0.760, 0.902,
  200 : 0.902, 0.616, 0.885,
  201 : 0.890, 0.482, 0.856,
  202 : 0.862, 0.339, 0.803,
  203 : 0.830, 0.235, 0.794,
  204 : 0.814, 0.186, 0.829,
  205 : 0.797, 0.139, 0.865,
  206 : 0.766, 0.090, 0.907,
  207 : 0.736, 0.055, 0.940
  208 : ];
  209 : 
  210 : real[int] cmaphsvPurples = [
  211 : 0.751, 1.000, 0.490,
  212 : 0.746, 0.865, 0.522,
  213 : 0.740, 0.742, 0.556,
  214 : 0.732, 0.629, 0.592,
  215 : 0.721, 0.527, 0.629,
  216 : 0.703, 0.433, 0.672,
  217 : 0.681, 0.352, 0.716,
  218 : 0.672, 0.295, 0.747,
  219 : 0.679, 0.252, 0.771,
  220 : 0.679, 0.208, 0.801,
  221 : 0.668, 0.165, 0.840,
  222 : 0.660, 0.133, 0.874,
  223 : 0.662, 0.096, 0.903,
  224 : 0.669, 0.067, 0.927,
  225 : 0.688, 0.047, 0.946,
  226 : 0.711, 0.031, 0.963
  227 : ];
  228 : 
  229 : real[int] cmaphsvRdPu = [
  230 : 0.781, 1.000, 0.416,
  231 : 0.808, 0.994, 0.443,
  232 : 0.834, 0.992, 0.467,
  233 : 0.859, 0.993, 0.563,
  234 : 0.876, 0.994, 0.659,
  235 : 0.887, 0.941, 0.753,
  236 : 0.898, 0.806, 0.841,
  237 : 0.911, 0.709, 0.906,
  238 : 0.927, 0.625, 0.957,
  239 : 0.939, 0.528, 0.973,
  240 : 0.950, 0.422, 0.978,
  241 : 0.967, 0.334, 0.982,
  242 : 0.994, 0.264, 0.986,
  243 : 0.018, 0.230, 0.989,
  244 : 0.020, 0.175, 0.990,
  245 : 0.016, 0.121, 0.992
  246 : ];
  247 : 
  248 : real[int] cmaphsvReds = [
  249 : 0.979, 1.000, 0.404,
  250 : 0.988, 0.942, 0.531,
  251 : 0.993, 0.912, 0.636,
  252 : 0.994, 0.898, 0.714,
  253 : 0.995, 0.887, 0.779,
  254 : 1.000, 0.849, 0.852,
  255 : 0.009, 0.827, 0.921,
  256 : 0.018, 0.791, 0.957,
  257 : 0.027, 0.736, 0.980,
  258 : 0.033, 0.672, 0.986,
  259 : 0.036, 0.597, 0.988,
  260 : 0.040, 0.517, 0.988,
  261 : 0.044, 0.429, 0.988,
  262 : 0.049, 0.338, 0.988,
  263 : 0.051, 0.244, 0.992,
  264 : 0.053, 0.165, 0.996
  265 : ];
  266 : 
  267 : real[int] cmaphsvYlGn = [
  268 : 0.432, 1.000, 0.271,
  269 : 0.426, 1.000, 0.339,
  270 : 0.422, 1.000, 0.401,
  271 : 0.412, 0.916, 0.453,
  272 : 0.392, 0.761, 0.503,
  273 : 0.382, 0.689, 0.570,
  274 : 0.379, 0.644, 0.646,
  275 : 0.370, 0.561, 0.705,
  276 : 0.350, 0.446, 0.754,
  277 : 0.319, 0.380, 0.799,
  278 : 0.286, 0.366, 0.842,
  279 : 0.258, 0.352, 0.881,
  280 : 0.233, 0.336, 0.918,
  281 : 0.211, 0.316, 0.948,
  282 : 0.191, 0.296, 0.974,
  283 : 0.178, 0.260, 0.989
  284 : ];
  285 : 
  286 : real[int] cmaphsvYlGnBu = [
  287 : 0.623, 0.909, 0.345,
  288 : 0.648, 0.778, 0.480,
  289 : 0.646, 0.748, 0.573,
  290 : 0.624, 0.770, 0.618,
  291 : 0.598, 0.792, 0.649,
  292 : 0.575, 0.820, 0.696,
  293 : 0.555, 0.846, 0.744,
  294 : 0.538, 0.826, 0.760,
  295 : 0.525, 0.726, 0.768,
  296 : 0.510, 0.605, 0.765,
  297 : 0.485, 0.460, 0.777,
  298 : 0.442, 0.335, 0.823,
  299 : 0.353, 0.213, 0.879,
  300 : 0.258, 0.237, 0.923,
  301 : 0.214, 0.269, 0.953,
  302 : 0.190, 0.287, 0.975
  303 : ];
  304 : 
  305 : real[int] cmaphsvYlOrBr = [
  306 : 0.054, 0.941, 0.400,
  307 : 0.052, 0.960, 0.494,
  308 : 0.053, 0.973, 0.588,
  309 : 0.056, 0.983, 0.687,
  310 : 0.060, 0.990, 0.781,
  311 : 0.065, 0.974, 0.851,
  312 : 0.069, 0.930, 0.908,
  313 : 0.075, 0.895, 0.953,
  314 : 0.083, 0.861, 0.990,
  315 : 0.093, 0.811, 0.996,
  316 : 0.105, 0.742, 0.996,
  317 : 0.114, 0.650, 0.996,
  318 : 0.120, 0.518, 0.996,
  319 : 0.128, 0.406, 0.996,
  320 : 0.138, 0.327, 0.999,
  321 : 0.148, 0.253, 1.000
  322 : ];
  323 : 
  324 : real[int] cmaphsvYlOrRd = [
  325 : 0.951, 1.000, 0.502,
  326 : 0.960, 1.000, 0.627,
  327 : 0.966, 1.000, 0.730,
  328 : 0.977, 0.970, 0.811,
  329 : 0.995, 0.902, 0.876,
  330 : 0.009, 0.871, 0.935,
  331 : 0.023, 0.844, 0.982,
  332 : 0.040, 0.814, 0.990,
  333 : 0.061, 0.779, 0.991,
  334 : 0.077, 0.749, 0.993,
  335 : 0.088, 0.723, 0.995,
  336 : 0.100, 0.680, 0.996,
  337 : 0.113, 0.600, 0.996,
  338 : 0.123, 0.516, 0.996,
  339 : 0.129, 0.440, 0.999,
  340 : 0.136, 0.363, 1.000
  341 : ];
  342 : 
  343 : ;
  135 : 
  136 :     if      (mapname == "Blues"  ) { cmaphsv = cmaphsvBlues;  }
  137 :     else if (mapname == "BuGn"   ) { cmaphsv = cmaphsvBuGn;   }
  138 :     else if (mapname == "BuPu"   ) { cmaphsv = cmaphsvBuPu;   }
  139 :     else if (mapname == "GnBu"   ) { cmaphsv = cmaphsvGnBu;   }
  140 :     else if (mapname == "Greens" ) { cmaphsv = cmaphsvGreens; }
  141 :     else if (mapname == "Greys"  ) { cmaphsv = cmaphsvGreys;  }
  142 :     else if (mapname == "OrRd"   ) { cmaphsv = cmaphsvOrRd;   }
  143 :     else if (mapname == "Oranges") { cmaphsv = cmaphsvOranges;}
  144 :     else if (mapname == "PuBu"   ) { cmaphsv = cmaphsvPuBu;   }
  145 :     else if (mapname == "PuBuGn" ) { cmaphsv = cmaphsvPuBuGn; }
  146 :     else if (mapname == "PuRd"   ) { cmaphsv = cmaphsvPuRd;   }
  147 :     else if (mapname == "Purples") { cmaphsv = cmaphsvPurples;}
  148 :     else if (mapname == "RdPu"   ) { cmaphsv = cmaphsvRdPu;   }
  149 :     else if (mapname == "Reds"   ) { cmaphsv = cmaphsvReds;   }
  150 :     else if (mapname == "YlGn"   ) { cmaphsv = cmaphsvYlGn;   }
  151 :     else if (mapname == "YlGnBu" ) { cmaphsv = cmaphsvYlGnBu; }
  152 :     else if (mapname == "YlOrBr" ) { cmaphsv = cmaphsvYlOrBr; }
  153 :     else if (mapname == "YlOrRd" ) { cmaphsv = cmaphsvYlOrRd; }
  154 : 
  155 :     return cmaphsv;
  156 : }
  157 : 
  158 : 
  159 : 
  160 : func real[int] CMoceanFF(string mapname)
  161 : {
  162 :     int N = 3*16;
 *** Warning  The identifier N hide a Global identifier  

  163 :     real[int] cmaphsv(N);
  164 : 
  165 :     include "colors_cmocean_16.edp"real[int] cmaphsvbalance = [
    2 : 0.972, 0.850, 0.236,
    3 : 0.959, 0.860, 0.408,
    4 : 0.973, 0.874, 0.582,
    5 : 0.021, 0.787, 0.703,
    6 : 0.039, 0.643, 0.766,
    7 : 0.042, 0.446, 0.816,
    8 : 0.041, 0.254, 0.862,
    9 : 0.036, 0.085, 0.913,
   10 : 0.571, 0.022, 0.878,
   11 : 0.543, 0.162, 0.795,
   12 : 0.546, 0.385, 0.743,
   13 : 0.561, 0.640, 0.729,
   14 : 0.576, 0.883, 0.736,
   15 : 0.619, 0.817, 0.713,
   16 : 0.642, 0.683, 0.477,
   17 : 0.649, 0.644, 0.262
   18 : ];
   19 : 
   20 : real[int] cmaphsvdelta = [
   21 : 0.288, 0.467, 0.137,
   22 : 0.396, 0.661, 0.264,
   23 : 0.396, 0.890, 0.390,
   24 : 0.299, 0.760, 0.504,
   25 : 0.212, 0.957, 0.594,
   26 : 0.168, 0.809, 0.675,
   27 : 0.140, 0.557, 0.850,
   28 : 0.142, 0.303, 0.956,
   29 : 0.267, 0.056, 0.922,
   30 : 0.458, 0.165, 0.810,
   31 : 0.494, 0.401, 0.712,
   32 : 0.528, 0.660, 0.672,
   33 : 0.556, 0.787, 0.640,
   34 : 0.591, 0.826, 0.617,
   35 : 0.633, 0.700, 0.479,
   36 : 0.614, 0.736, 0.249
   37 : ];
   38 : 
   39 : real[int] cmaphsvcurl = [
   40 : 0.828, 0.754, 0.209,
   41 : 0.857, 0.786, 0.376,
   42 : 0.902, 0.746, 0.544,
   43 : 0.951, 0.634, 0.683,
   44 : 0.001, 0.510, 0.791,
   45 : 0.036, 0.456, 0.859,
   46 : 0.052, 0.296, 0.904,
   47 : 0.053, 0.111, 0.957,
   48 : 0.145, 0.052, 0.910,
   49 : 0.292, 0.134, 0.795,
   50 : 0.390, 0.296, 0.702,
   51 : 0.455, 0.613, 0.608,
   52 : 0.494, 0.866, 0.491,
   53 : 0.527, 0.755, 0.416,
   54 : 0.570, 0.685, 0.340,
   55 : 0.637, 0.689, 0.265
   56 : ];
   57 : 
   58 : real[int] cmaphsvphase = [
   59 : 0.115, 0.925, 0.658,
   60 : 0.169, 0.898, 0.533,
   61 : 0.269, 0.729, 0.587,
   62 : 0.422, 0.836, 0.604,
   63 : 0.479, 0.900, 0.594,
   64 : 0.525, 0.821, 0.658,
   65 : 0.573, 0.711, 0.795,
   66 : 0.640, 0.551, 0.911,
   67 : 0.719, 0.581, 0.957,
   68 : 0.777, 0.682, 0.928,
   69 : 0.833, 0.773, 0.817,
   70 : 0.889, 0.825, 0.869,
   71 : 0.949, 0.728, 0.863,
   72 : 0.015, 0.660, 0.817,
   73 : 0.068, 0.783, 0.749,
   74 : 0.115, 0.925, 0.658
   75 : ];
   76 : 
   77 : real[int] cmaphsvthermal = [
   78 : 0.186, 0.638, 0.982,
   79 : 0.145, 0.690, 0.954,
   80 : 0.116, 0.745, 0.980,
   81 : 0.092, 0.760, 0.987,
   82 : 0.067, 0.721, 0.970,
   83 : 0.037, 0.626, 0.920,
   84 : 0.999, 0.496, 0.838,
   85 : 0.953, 0.476, 0.740,
   86 : 0.900, 0.441, 0.640,
   87 : 0.828, 0.412, 0.552,
   88 : 0.763, 0.501, 0.574,
   89 : 0.721, 0.598, 0.604,
   90 : 0.685, 0.675, 0.625,
   91 : 0.628, 0.786, 0.508,
   92 : 0.586, 0.899, 0.338,
   93 : 0.557, 0.923, 0.202
   94 : ];
   95 : 
   96 : real[int] cmaphsvhaline = [
   97 : 0.142, 0.394, 0.994,
   98 : 0.174, 0.465, 0.896,
   99 : 0.209, 0.556, 0.862,
  100 : 0.256, 0.558, 0.829,
  101 : 0.322, 0.464, 0.783,
  102 : 0.387, 0.517, 0.727,
  103 : 0.429, 0.563, 0.666,
  104 : 0.462, 0.585, 0.605,
  105 : 0.494, 0.604, 0.546,
  106 : 0.523, 0.673, 0.537,
  107 : 0.545, 0.769, 0.544,
  108 : 0.564, 0.874, 0.560,
  109 : 0.588, 0.914, 0.589,
  110 : 0.634, 0.819, 0.631,
  111 : 0.690, 0.801, 0.586,
  112 : 0.701, 0.775, 0.423
  113 : ];
  114 : 
  115 : real[int] cmaphsvsolar = [
  116 : 0.194, 0.705, 0.994,
  117 : 0.174, 0.725, 0.902,
  118 : 0.154, 0.762, 0.863,
  119 : 0.138, 0.805, 0.846,
  120 : 0.125, 0.843, 0.824,
  121 : 0.113, 0.874, 0.798,
  122 : 0.101, 0.894, 0.767,
  123 : 0.089, 0.899, 0.732,
  124 : 0.076, 0.886, 0.692,
  125 : 0.060, 0.859, 0.646,
  126 : 0.042, 0.815, 0.592,
  127 : 0.023, 0.754, 0.527,
  128 : 0.005, 0.683, 0.451,
  129 : 0.991, 0.652, 0.367,
  130 : 0.983, 0.632, 0.284,
  131 : 0.978, 0.616, 0.201
  132 : ];
  133 : 
  134 : real[int] cmaphsvice = [
  135 : 0.502, 0.075, 0.993,
  136 : 0.511, 0.144, 0.932,
  137 : 0.514, 0.234, 0.877,
  138 : 0.524, 0.343, 0.838,
  139 : 0.538, 0.437, 0.809,
  140 : 0.552, 0.511, 0.782,
  141 : 0.565, 0.574, 0.756,
  142 : 0.579, 0.623, 0.731,
  143 : 0.596, 0.647, 0.704,
  144 : 0.617, 0.631, 0.663,
  145 : 0.642, 0.582, 0.589,
  146 : 0.662, 0.530, 0.484,
  147 : 0.672, 0.511, 0.373,
  148 : 0.673, 0.506, 0.267,
  149 : 0.662, 0.542, 0.168,
  150 : 0.646, 0.789, 0.073
  151 : ];
  152 : 
  153 : real[int] cmaphsvgray = [
  154 : 0.147, 0.006, 0.999,
  155 : 0.142, 0.006, 0.912,
  156 : 0.135, 0.007, 0.829,
  157 : 0.127, 0.007, 0.751,
  158 : 0.119, 0.007, 0.678,
  159 : 0.110, 0.008, 0.607,
  160 : 0.101, 0.008, 0.540,
  161 : 0.092, 0.009, 0.475,
  162 : 0.083, 0.009, 0.412,
  163 : 0.074, 0.010, 0.351,
  164 : 0.064, 0.011, 0.291,
  165 : 0.055, 0.012, 0.231,
  166 : 0.044, 0.014, 0.170,
  167 : 0.032, 0.017, 0.108,
  168 : 0.013, 0.026, 0.040,
  169 : 0.620, 0.914, 0.000
  170 : ];
  171 : 
  172 : real[int] cmaphsvoxy = [
  173 : 0.128, 0.884, 0.865,
  174 : 0.144, 0.837, 0.895,
  175 : 0.164, 0.762, 0.916,
  176 : 0.173, 0.125, 0.969,
  177 : 0.139, 0.006, 0.876,
  178 : 0.131, 0.007, 0.793,
  179 : 0.123, 0.007, 0.715,
  180 : 0.114, 0.007, 0.641,
  181 : 0.105, 0.008, 0.571,
  182 : 0.096, 0.008, 0.503,
  183 : 0.087, 0.009, 0.438,
  184 : 0.077, 0.010, 0.374,
  185 : 0.023, 0.302, 0.363,
  186 : 0.986, 0.959, 0.477,
  187 : 0.990, 0.922, 0.363,
  188 : 0.001, 0.921, 0.250
  189 : ];
  190 : 
  191 : real[int] cmaphsvdeep = [
  192 : 0.794, 0.406, 0.173,
  193 : 0.735, 0.431, 0.268,
  194 : 0.701, 0.461, 0.373,
  195 : 0.669, 0.477, 0.483,
  196 : 0.628, 0.557, 0.559,
  197 : 0.594, 0.585, 0.583,
  198 : 0.567, 0.576, 0.597,
  199 : 0.542, 0.555, 0.611,
  200 : 0.517, 0.530, 0.626,
  201 : 0.489, 0.513, 0.660,
  202 : 0.461, 0.500, 0.728,
  203 : 0.427, 0.439, 0.792,
  204 : 0.376, 0.326, 0.848,
  205 : 0.299, 0.252, 0.896,
  206 : 0.233, 0.231, 0.944,
  207 : 0.168, 0.195, 0.994
  208 : ];
  209 : 
  210 : real[int] cmaphsvdense = [
  211 : 0.908, 0.738, 0.213,
  212 : 0.883, 0.750, 0.292,
  213 : 0.850, 0.729, 0.358,
  214 : 0.814, 0.684, 0.442,
  215 : 0.783, 0.642, 0.547,
  216 : 0.755, 0.596, 0.645,
  217 : 0.726, 0.548, 0.733,
  218 : 0.694, 0.496, 0.807,
  219 : 0.657, 0.463, 0.861,
  220 : 0.624, 0.492, 0.890,
  221 : 0.598, 0.483, 0.896,
  222 : 0.579, 0.427, 0.891,
  223 : 0.562, 0.339, 0.887,
  224 : 0.546, 0.235, 0.891,
  225 : 0.526, 0.132, 0.908,
  226 : 0.499, 0.044, 0.944
  227 : ];
  228 : 
  229 : real[int] cmaphsvalgae = [
  230 : 0.356, 0.515, 0.142,
  231 : 0.388, 0.556, 0.199,
  232 : 0.405, 0.612, 0.256,
  233 : 0.415, 0.678, 0.314,
  234 : 0.421, 0.754, 0.372,
  235 : 0.425, 0.840, 0.432,
  236 : 0.427, 0.927, 0.492,
  237 : 0.421, 0.934, 0.552,
  238 : 0.399, 0.794, 0.610,
  239 : 0.363, 0.598, 0.661,
  240 : 0.331, 0.452, 0.707,
  241 : 0.313, 0.392, 0.755,
  242 : 0.303, 0.331, 0.806,
  243 : 0.298, 0.272, 0.859,
  244 : 0.299, 0.216, 0.916,
  245 : 0.304, 0.166, 0.977
  246 : ];
  247 : 
  248 : real[int] cmaphsvmatter = [
  249 : 0.781, 0.757, 0.243,
  250 : 0.812, 0.735, 0.299,
  251 : 0.842, 0.745, 0.358,
  252 : 0.868, 0.776, 0.448,
  253 : 0.892, 0.787, 0.537,
  254 : 0.915, 0.774, 0.623,
  255 : 0.939, 0.743, 0.704,
  256 : 0.965, 0.699, 0.777,
  257 : 0.991, 0.641, 0.840,
  258 : 0.017, 0.634, 0.887,
  259 : 0.037, 0.624, 0.920,
  260 : 0.052, 0.587, 0.944,
  261 : 0.066, 0.532, 0.962,
  262 : 0.082, 0.466, 0.975,
  263 : 0.102, 0.389, 0.986,
  264 : 0.132, 0.305, 0.994
  265 : ];
  266 : 
  267 : real[int] cmaphsvturbid = [
  268 : 0.081, 0.207, 0.134,
  269 : 0.067, 0.312, 0.201,
  270 : 0.063, 0.382, 0.268,
  271 : 0.062, 0.439, 0.336,
  272 : 0.064, 0.489, 0.406,
  273 : 0.068, 0.538, 0.475,
  274 : 0.074, 0.582, 0.542,
  275 : 0.082, 0.619, 0.604,
  276 : 0.091, 0.644, 0.660,
  277 : 0.101, 0.649, 0.709,
  278 : 0.111, 0.628, 0.750,
  279 : 0.123, 0.579, 0.783,
  280 : 0.136, 0.509, 0.813,
  281 : 0.151, 0.429, 0.844,
  282 : 0.172, 0.353, 0.886,
  283 : 0.196, 0.302, 0.964
  284 : ];
  285 : 
  286 : real[int] cmaphsvspeed = [
  287 : 0.288, 0.467, 0.137,
  288 : 0.369, 0.504, 0.200,
  289 : 0.396, 0.660, 0.264,
  290 : 0.403, 0.809, 0.328,
  291 : 0.396, 0.890, 0.390,
  292 : 0.362, 0.788, 0.449,
  293 : 0.300, 0.759, 0.503,
  294 : 0.248, 0.868, 0.551,
  295 : 0.213, 0.956, 0.594,
  296 : 0.189, 0.932, 0.634,
  297 : 0.169, 0.811, 0.674,
  298 : 0.151, 0.689, 0.768,
  299 : 0.140, 0.560, 0.849,
  300 : 0.137, 0.429, 0.907,
  301 : 0.142, 0.306, 0.955,
  302 : 0.160, 0.196, 1.000
  303 : ];
  304 : 
  305 : real[int] cmaphsvamp = [
  306 : 0.972, 0.850, 0.236,
  307 : 0.963, 0.840, 0.321,
  308 : 0.959, 0.860, 0.408,
  309 : 0.960, 0.890, 0.497,
  310 : 0.972, 0.875, 0.582,
  311 : 0.997, 0.793, 0.651,
  312 : 0.021, 0.787, 0.702,
  313 : 0.034, 0.732, 0.737,
  314 : 0.039, 0.644, 0.766,
  315 : 0.042, 0.547, 0.792,
  316 : 0.042, 0.448, 0.815,
  317 : 0.042, 0.350, 0.838,
  318 : 0.041, 0.256, 0.861,
  319 : 0.039, 0.167, 0.885,
  320 : 0.036, 0.087, 0.912,
  321 : 0.026, 0.022, 0.946
  322 : ];
  323 : 
  324 : real[int] cmaphsvtempo = [
  325 : 0.637, 0.689, 0.265,
  326 : 0.598, 0.680, 0.302,
  327 : 0.570, 0.685, 0.340,
  328 : 0.547, 0.709, 0.379,
  329 : 0.527, 0.754, 0.416,
  330 : 0.510, 0.818, 0.449,
  331 : 0.494, 0.866, 0.490,
  332 : 0.478, 0.789, 0.551,
  333 : 0.455, 0.616, 0.607,
  334 : 0.426, 0.441, 0.655,
  335 : 0.391, 0.298, 0.701,
  336 : 0.347, 0.187, 0.746,
  337 : 0.293, 0.135, 0.794,
  338 : 0.239, 0.091, 0.846,
  339 : 0.149, 0.053, 0.907,
  340 : 0.023, 0.041, 0.999
  341 : ];
  342 : 
  343 : ;
  166 : 
  167 :     if      (mapname == "balance") { cmaphsv = cmaphsvbalance;}
  168 :     else if (mapname == "delta"  ) { cmaphsv = cmaphsvdelta  ;}
  169 :     else if (mapname == "curl"   ) { cmaphsv = cmaphsvcurl   ;}
  170 :     else if (mapname == "thermal") { cmaphsv = cmaphsvthermal;}
  171 :     else if (mapname == "haline" ) { cmaphsv = cmaphsvhaline ;}
  172 :     else if (mapname == "solar"  ) { cmaphsv = cmaphsvsolar  ;}
  173 :     else if (mapname == "ice"    ) { cmaphsv = cmaphsvice    ;}
  174 :     else if (mapname == "gray"   ) { cmaphsv = cmaphsvgray   ;}
  175 :     else if (mapname == "oxy"    ) { cmaphsv = cmaphsvoxy    ;}
  176 :     else if (mapname == "deep"   ) { cmaphsv = cmaphsvdeep   ;}
  177 :     else if (mapname == "dense"  ) { cmaphsv = cmaphsvdense  ;}
  178 :     else if (mapname == "algae"  ) { cmaphsv = cmaphsvalgae  ;}
  179 :     else if (mapname == "matter" ) { cmaphsv = cmaphsvmatter ;}
  180 :     else if (mapname == "turbid" ) { cmaphsv = cmaphsvturbid ;}
  181 :     else if (mapname == "speed"  ) { cmaphsv = cmaphsvspeed  ;}
  182 :     else if (mapname == "amp"    ) { cmaphsv = cmaphsvamp    ;}
  183 :     else if (mapname == "tempo"  ) { cmaphsv = cmaphsvtempo  ;}
  184 :     else if (mapname == "phase"  ) { cmaphsv = cmaphsvphase  ;}
  185 : 
  186 :     return cmaphsv;
  187 : }
  188 : 
  189 : ;
   18 : 
   19 : cmap = CMoceanFF("curl");
   20 : kmap = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0];
   21 : 
   22 : 
   23 : 
   24 : // Set the parameters.
   25 : 
   26 : include "params.edp"Re = 100;
    2 : invFr = 0.00;
    3 : 
    4 : xmax = 20;
    5 : ymax = 20;
    6 : 
    7 : dirsrc = "/Users/wil/Documents/Work/Projects/Stratified-Wak
  ... : es/Stability/src/";
    8 : dirdat = "/Users/wil/Documents/Work/Projects/Stratified-Wak
  ... : es/Stability/dat/tests/20180201T155632-Re000100_in
  ... : vFr0000.000_xmax0020_ymax0020/";
    9 : 
   10 : dirbase     = dirdat + "base/";
   11 : dirstab     = dirdat + "stab/";
   12 : 
   13 : dirbaseeps  = dirbase + "eps/";
   14 : dirbasegrid = dirbase + "grid/";
   15 : 
   16 : system("mkdir -p " + dirbase);
   17 : system("mkdir -p " + dirstab);
   18 : system("mkdir -p " + dirbaseeps);
   19 : system("mkdir -p " + dirbasegrid);
   20 : 
   21 : ;
   27 : 
   28 : 
   29 : 
   30 : // Make a mesh, later we will adapt it to the solution.
   31 : 
   32 : include "mesh.edp"func mesh MakeMesh(real xmax, real ymax)
    2 : {
    3 :     real lex = 2.0*ymax;
    4 :     real ley = 2.0*xmax;
    5 : 
    6 :     border S1(t = -1.0,  1.0){x =   xmax; y = t*ymax; label = right; };
    7 :     border S2(t =  1.0, -1.0){x = t*xmax; y =   ymax; label = top;   };
    8 :     border S3(t =  1.0, -1.0){x =  -xmax; y = t*ymax; label = left;  };
    9 :     border S4(t = -1.0,  1.0){x = t*xmax; y =  -ymax; label = bottom;};
   10 :     border A1(t = -1.0,  1.0){x = t*xmax; y =    0.0; label = aux;   };
   11 :     border A2(t = -1.0,  1.0){x =    0.0; y = t*ymax; label = aux;   };
   12 : 
   13 :     int ney = 4 * ley;
   14 :     int nex = 4 * lex;
   15 : 
   16 :     mesh Th = buildmesh( S1(ney) 
   17 :                        + S2(nex)
   18 :                        + S3(ney)
   19 :                        + S4(ney)
   20 :                        + A1(nex)
   21 :                        + A2(nex) );
   22 : 
   23 :     func rr = sqrt(x^2 + y^2);
   24 :     func fadpt = min(2.0, max(0.01, 2.0*(1.0-(1.0-0.1)*exp(-log(2.0)*(rr/8.0)^2))));
   25 : 
   26 :     for (int k = 1; k <= 3; k++)
   27 :     {
   28 :         Th = adaptmesh(Th, fadpt, IsMetric = 1, hmin = 0.01, hmax = 2.0, nbvx = 99999);
   29 :     }
   30 : 
   31 :     return Th;
   32 : }
   33 : 
   34 : ;
   33 : 
   34 : Th = MakeMesh(xmax, ymax);
   35 : 
   36 : plot(Th, wait = 0);
   37 : 
   38 : 
   39 : 
   40 : // Construct a fake base flow.
   41 : 
   42 : func r = x^2 + y^2;
   43 : 
   44 : Uc   = 0.5;
   45 : beta = 1.0;
   46 : 
   47 : for (int kk = 1; kk <= 3; kk++)
   48 : {
   49 :     p0 = 0.0;
   50 :     u1 = 0.0;
   51 :     u2 = 0.0;
   52 :     u3 = Uc + (1.0 - Uc) * (0.5 - 0.5*tanh(beta*(1.0/max(r, 1.0e-9) - r)));
   53 :     ro = 1.0;
   54 : 
   55 :     Th = adaptmesh(Th, u3, err = 0.01, ratio = 1.2, hmax = 0.5, hmin = 0.01, nbvx = 999999);
   56 : 
   57 :     p0 = p0;
   58 :     u1 = u1;
   59 :     u2 = u2;
   60 :     u3 = u3;
   61 :     ro = ro;
   62 : }
   63 : 
   64 : plot(Th, wait = 1);
   65 : plot(u3, fill = 1, value = 1, nbiso = 16, hsv = cmap, wait = 1);
   66 : 
   67 : 
   68 : 
   69 : // Write final solution:
   70 : 
   71 : include "write_sol.edp"savemesh(Th, dirbase + "mesh0.msh");
    2 : 
    3 : { ofstream file(dirbase + "Re.dat"   );   file << Re    << endl; }
    4 : { ofstream file(dirbase + "invFr.dat");   file << invFr << endl; }
    5 : { ofstream file(dirbase + "xmax.dat" );   file << xmax  << endl; }
    6 : { ofstream file(dirbase + "ymax.dat" );   file << ymax  << endl; }
    7 : 
    8 : { ofstream file(dirbase + "p0.dat"); file << p0[] << endl; }
    9 : { ofstream file(dirbase + "u1.dat"); file << u1[] << endl; }
   10 : { ofstream file(dirbase + "u2.dat"); file << u2[] << endl; }
   11 : { ofstream file(dirbase + "u3.dat"); file << u3[] << endl; }
   12 : { ofstream file(dirbase + "ro.dat"); file << ro[] << endl; }
   13 : 
   14 : {
   15 :     ofstream file(dirbase + "coordinates.dat");
   16 : 
   17 :     for (int j = 0; j < Th.nv; j++)
   18 :     {
   19 :         file << Th(j).x << " " << Th(j).y << endl;
   20 :     }
   21 : }
   22 : {
   23 :     ofstream file(dirbase + "connectivity.dat");
   24 : 
   25 :     int nbtriangle = Th.nt;
   26 : 
   27 :     for (int i = 0; i < Th.nt; i++)
   28 :     {
   29 :         file << Th[i][0] + 1 << " " << Th[i][1] + 1 << " " << Th[i][2] + 1 << endl;
   30 :     }
   31 : }
   32 : 
   33 : ;
   72 : 
   73 : //include "write_figs.edp";
   74 : 
   75 : include "write_sol_grid.edp"func int WriteOnGrid(real x1G, real y1G, real x2G, real y2G, int N1x, int N1y, string sffx)
    2 : {
    3 :     // x1 should be smaller than x2
    4 :     // y1 should be smaller than y2
    5 : 
    6 :     real Dx = 1.0/N1x;
    7 :     real Dy = 1.0/N1y;
    8 : 
    9 :     real[int] xV = x1G : Dx : x2G;
   10 :     real[int] yV = y1G : Dy : y2G;
   11 : 
   12 :     int Nx = xV.n;
   13 :     int Ny = yV.n;
   14 : 
   15 :     real[int, int] xxG(Ny, Nx);
   16 :     real[int, int] yyG(Ny, Nx);
   17 :     real[int, int] p0G(Ny, Nx);
   18 :     real[int, int] u1G(Ny, Nx);
   19 :     real[int, int] u2G(Ny, Nx);
   20 :     real[int, int] u3G(Ny, Nx);
   21 :     real[int, int] roG(Ny, Nx);
   22 :  // real[int, int] sfG(Ny, Nx);
   23 : 
   24 :     for (int iy = 0; iy < Ny; iy++)
   25 :     {
   26 :         for (int ix = 0; ix < Nx; ix++)
   27 :         {
   28 :             xxG(iy, ix) = xV(ix);
   29 :             yyG(iy, ix) = yV(iy);
   30 : 
   31 :             p0G(iy, ix) = p0(xV(ix), yV(iy));
   32 :             u1G(iy, ix) = u1(xV(ix), yV(iy));
   33 :             u2G(iy, ix) = u2(xV(ix), yV(iy));
   34 :             u3G(iy, ix) = u3(xV(ix), yV(iy));
   35 :             roG(iy, ix) = ro(xV(ix), yV(iy));
   36 : //          sfG(iy, ix) = sf(xV(ix), yV(iy));
   37 :         }
   38 :     }
   39 : 
   40 :     { ofstream file(dirbasegrid + "G_xx" + sffx + ".dat"); file << xxG << endl; }
   41 :     { ofstream file(dirbasegrid + "G_yy" + sffx + ".dat"); file << yyG << endl; }
   42 :     { ofstream file(dirbasegrid + "G_p0" + sffx + ".dat"); file << p0G << endl; }
   43 :     { ofstream file(dirbasegrid + "G_u1" + sffx + ".dat"); file << u1G << endl; }
   44 :     { ofstream file(dirbasegrid + "G_u2" + sffx + ".dat"); file << u2G << endl; }
   45 :     { ofstream file(dirbasegrid + "G_u3" + sffx + ".dat"); file << u3G << endl; }
   46 :     { ofstream file(dirbasegrid + "G_ro" + sffx + ".dat"); file << roG << endl; }
   47 : //  { ofstream file(dirbasegrid + "G_sf" + sffx + ".dat"); file << sfG << endl; }
   48 : 
   49 :     exec("echo " + N1x + " >> " + dirbasegrid + "G_N1x.dat");
   50 :     exec("echo " + N1y + " >> " + dirbasegrid + "G_N1y.dat");
   51 : 
   52 :     return 1;
   53 : }
   54 : 
   55 : 
   56 : 
   57 : func int WriteOnLine(real x1L, real y1L, real x2L, real y2L, int N1L, string sffx)
   58 : {
   59 :     // x1 should be smaller or equal than x2
   60 :     // y1 should be smaller or equal than y2
   61 : 
   62 :     real DrL = 1.0/N1L;
   63 : 
   64 :     real LxL = x2L - x1L;
   65 :     real LyL = y2L - y1L;
   66 : 
   67 :     real LrL = sqrt(LxL^2 + LyL^2);
   68 : 
   69 :     real[int] rVL = 0.0 : DrL : LrL;
   70 : 
   71 :     int NrL = rVL.n;
   72 : 
   73 :     real DxL = (x2L - x1L)/(NrL - 1);
   74 :     real DyL = (y2L - y1L)/(NrL - 1);
   75 : 
   76 :     real[int] xVL = rVL;
   77 :     real[int] yVL = rVL;
   78 : 
   79 :     if      (DxL < 1.0e-9)
   80 :     {
   81 :         yVL = y1L : DyL : y2L;
   82 :         xVL(:) = 0.0;
   83 :     }
   84 :     else if (DyL < 1.0e-9)
   85 :     {
   86 :         xVL = x1L : DxL : x2L;
   87 :         yVL(:) = 0.0;
   88 :     }
   89 :     else
   90 :     {
   91 :         xVL = x1L : DxL : x2L;
   92 :         yVL = y1L : DyL : y2L;
   93 :     }
   94 : 
   95 :     real[int, int] rrL(NrL, 1);
   96 :     real[int, int] xxL(NrL, 1);
   97 :     real[int, int] yyL(NrL, 1);
   98 :     real[int, int] p0L(NrL, 1);
   99 :     real[int, int] u1L(NrL, 1);
  100 :     real[int, int] u2L(NrL, 1);
  101 :     real[int, int] u3L(NrL, 1);
  102 :     real[int, int] roL(NrL, 1);
  103 : 
  104 :     for (int ir = 0; ir < NrL; ir++)
  105 :     {
  106 :         rrL(ir, 0) = rVL(ir);
  107 :         xxL(ir, 0) = xVL(ir);
  108 :         yyL(ir, 0) = yVL(ir);
  109 : 
  110 :         p0L(ir, 0) = p0(xVL(ir), yVL(ir));
  111 :         u1L(ir, 0) = u1(xVL(ir), yVL(ir));
  112 :         u2L(ir, 0) = u2(xVL(ir), yVL(ir));
  113 :         u3L(ir, 0) = u3(xVL(ir), yVL(ir));
  114 :         roL(ir, 0) = ro(xVL(ir), yVL(ir));
  115 :     }
  116 : 
  117 :     { ofstream file(dirbasegrid + "L_rr" + sffx + ".dat"); file << rrL << endl; }
  118 :     { ofstream file(dirbasegrid + "L_xx" + sffx + ".dat"); file << xxL << endl; }
  119 :     { ofstream file(dirbasegrid + "L_yy" + sffx + ".dat"); file << yyL << endl; }
  120 :     { ofstream file(dirbasegrid + "L_p0" + sffx + ".dat"); file << p0L << endl; }
  121 :     { ofstream file(dirbasegrid + "L_u1" + sffx + ".dat"); file << u1L << endl; }
  122 :     { ofstream file(dirbasegrid + "L_u2" + sffx + ".dat"); file << u2L << endl; }
  123 :     { ofstream file(dirbasegrid + "L_u3" + sffx + ".dat"); file << u3L << endl; }
  124 :     { ofstream file(dirbasegrid + "L_ro" + sffx + ".dat"); file << roL << endl; }
  125 : 
  126 :     exec("echo " + N1L + " >> " + dirbasegrid + "L_N1.dat");
  127 : 
  128 :     return 1;
  129 : }
  130 : 
  131 : ;
   76 : 
   77 : WriteOnGrid(-xmax, -ymax, xmax, ymax, 4, 4, "");
   78 : 
   79 : WriteOnLine(-xmax,   0.0, xmax,  0.0, 100, "_hor");
   80 : 
   81 : WriteOnLine(  0.0, -ymax,  0.0, ymax, 100, "_ver");
   82 : 
   83 : include "write_split_mesh.edp"Th2 = splitmesh(Th, 2);
    2 : 
    3 : savemesh(Th2, dirbase + "mesh-2.msh");
    4 : 
    5 : {
    6 :     ofstream file(dirbase + "coordinates-2.dat");
    7 : 
    8 :     for (int j = 0; j < Th2.nv; j++)
    9 :     {
   10 :         file << Th2(j).x << " " << Th2(j).y << endl;
   11 :     }
   12 : }
   13 : 
   14 : {
   15 :     ofstream file(dirbase + "connectivity-2.dat");
   16 : 
   17 :     int nbtriangle = Th2.nt;
   18 : 
   19 :     for (int i = 0; i < Th2.nt; i++)
   20 :     {
   21 :         file << Th2[i][0] + 1 << " " << Th2[i][1] + 1 << " " << Th2[i][2] + 1 << endl;
   22 :     }
   23 : }
   24 : ;
   84 : 
   85 : { ofstream file(dirbase + "success.dat"); file << 1 << endl; }
   86 : 
   87 :  sizestack + 1024 =13688  ( 12664 )

exec: mkdir -p /Users/wil/Documents/Work/Projects/Stratified-Wakes/Stability/dat/tests/20180201T155632-Re000100_invFr0000.000_xmax0020_ymax0020/base/
exec: mkdir -p /Users/wil/Documents/Work/Projects/Stratified-Wakes/Stability/dat/tests/20180201T155632-Re000100_invFr0000.000_xmax0020_ymax0020/stab/
exec: mkdir -p /Users/wil/Documents/Work/Projects/Stratified-Wakes/Stability/dat/tests/20180201T155632-Re000100_invFr0000.000_xmax0020_ymax0020/base/eps/
exec: mkdir -p /Users/wil/Documents/Work/Projects/Stratified-Wakes/Stability/dat/tests/20180201T155632-Re000100_invFr0000.000_xmax0020_ymax0020/base/grid/
  --  mesh:  Nb of Triangles =  60050, Nb of Vertices 30346
  number of required edges : 0
  -- adaptmesh Regulary:  Nb triangles 2934 , h  min 0.154608 , h max 2.67441
     area =  1600 , M area = 1221.24 , M area/( |Khat| nt) 0.961259
     infiny-regulaty:  min 0.490674  max 1.65575
     anisomax  2.45249, beta max = 1.30571 min  0.766929
  --  mesh:  Nb of Triangles =   2934, Nb of Vertices 1508
  number of required edges : 0
  -- adaptmesh Regulary:  Nb triangles 2922 , h  min 0.149262 , h max 2.56956
     area =  1600 , M area = 1221.59 , M area/( |Khat| nt) 0.965487
     infiny-regulaty:  min 0.48668  max 1.66819
     anisomax  2.43606, beta max = 1.25926 min  0.770085
  --  mesh:  Nb of Triangles =   2922, Nb of Vertices 1502
  number of required edges : 0
  -- adaptmesh Regulary:  Nb triangles 2920 , h  min 0.147817 , h max 2.5674
     area =  1600 , M area = 1221.7 , M area/( |Khat| nt) 0.966229
     infiny-regulaty:  min 0.477852  max 1.6776
     anisomax  2.47541, beta max = 1.27057 min  0.773279
  --  mesh:  Nb of Triangles =   2920, Nb of Vertices 1501
  number of required edges : 0
  -- adaptmesh Regulary:  Nb triangles 18248 , h  min 0.0339846 , h max 0.803383
     area =  1600 , M area = 7912.22 , M area/( |Khat| nt) 1.00134
     infiny-regulaty:  min 0.462934  max 1.82889
     anisomax  5.74485, beta max = 1.32488 min  0.705563
  --  mesh:  Nb of Triangles =  18248, Nb of Vertices 9285
  number of required edges : 0
  -- adaptmesh Regulary:  Nb triangles 18426 , h  min 0.0291521 , h max 0.729472
     area =  1600 , M area = 8202.98 , M area/( |Khat| nt) 1.02811
     infiny-regulaty:  min 0.456609  max 1.75891
     anisomax  5.26522, beta max = 1.32043 min  0.73529
  --  mesh:  Nb of Triangles =  18426, Nb of Vertices 9374
  number of required edges : 0
  -- adaptmesh Regulary:  Nb triangles 18446 , h  min 0.029619 , h max 0.718505
     area =  1600 , M area = 8231.32 , M area/( |Khat| nt) 1.03054
     infiny-regulaty:  min 0.454944  max 1.82241
     anisomax  4.87548, beta max = 1.30178 min  0.701043
  --  mesh:  Nb of Triangles =  18446, Nb of Vertices 9384
  number of required edges : 0
exec: echo 4 >> /Users/wil/Documents/Work/Projects/Stratified-Wakes/Stability/dat/tests/20180201T155632-Re000100_invFr0000.000_xmax0020_ymax0020/base/grid/G_N1x.dat
exec: echo 4 >> /Users/wil/Documents/Work/Projects/Stratified-Wakes/Stability/dat/tests/20180201T155632-Re000100_invFr0000.000_xmax0020_ymax0020/base/grid/G_N1y.dat
exec: echo 100 >> /Users/wil/Documents/Work/Projects/Stratified-Wakes/Stability/dat/tests/20180201T155632-Re000100_invFr0000.000_xmax0020_ymax0020/base/grid/L_N1.dat
exec: echo 100 >> /Users/wil/Documents/Work/Projects/Stratified-Wakes/Stability/dat/tests/20180201T155632-Re000100_invFr0000.000_xmax0020_ymax0020/base/grid/L_N1.dat
  -- Splitmesh 0x7ff1674335d0 split  min: 2 max: 2
  number of required edges : 0
times: compile 0.046038s, execution 4.48423s,  mpirank:0
 ######## We forget of deleting   0 Nb pointer,   0Bytes  ,  mpirank 0, memory leak =257168
 CodeAlloc : nb ptr  7916,  size :501960 mpirank: 0
Ok: Normal End
